function [f, g, data] = bsRegJTT(x, data, isInitial)
%% Regularization function, return the value and gradient of function $(1-alpha)|D_{TK} x|_2^2 + alpha * |D_{TV} x|_1$ 
% Bin She, bin.stepbystep@gmail.com, March, 2019
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INPUT
%
% x             is a column vector; refers to the parameter to be estimated.
%
% data.TKDiffOrder is a scalar; refers to the order of difference
% operator D_TK (D_TK will be generated by this parameter, defaut data.TKDiffOrder is 2,
% meaning D_TK is a second-order difference operator.
%
% data.TVDiffOrder is a scalar; refers to the order of difference
% operator D_TV (D_TV will be generated by this parameter, defaut data.diffOrder is 1,
% meaning D_TV is a first-order difference operator.
%
% data.alpha is a scalar; refers to the weight parameter that banlances
% the two terms: (1-alpha)|D_{TK} x|_2^2, |D_{TV} x|_1, its defaut values is set to 0.5
%
% isInitial is a logical; if it is true, the function will only perform
% some initial steps.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OUTPUT
% f             is a scalar; refers to (1-alpha)|D_{TK} x|_2^2 + alpha * |D_{TV} x|_1.
%
% g             is a column vector; refers to the gradient of (1-alpha)|D_{TK} x|_2^2 + alpha * |D_{TV} x|_1 with respect to x.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    if nargin == 3 && isInitial
       
        [~, data] = bsGetFieldsWithDefaults(data, {'diffOrder1', 1; 'diffOrder2', 2; 'alpha', 0.5; 'nSegments', 1});
        validateattributes(data.diffOrder2, {'double'}, {'>=', 1, '<=', 3});
        data.D_TK = bsGen1DDiffOperator(length(x), data.nSegments, data.diffOrder2);
        
        validateattributes(data.diffOrder1, {'double'}, {'>=', 1, '<=', 3});
        data.D_TV = bsGen1DDiffOperator(length(x), data.nSegments, data.diffOrder1);
        
        d1 = sum(abs(data.D_TV * x));
        z = data.D_TK * x;
        d2 = z' * z;
        
        data.D_TK = data.D_TK * (1-data.alpha) / sqrt(d2);
        data.D_TV = data.D_TV * data.alpha / d1; 
        
        validateattributes(data.alpha, {'double'}, {'>=', 0, '<=', 1});
       
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % calculate the information of the TK term
    z = data.D_TK * x;
    f1 = z' * z;
    g1 = 2 * data.D_TK' * z;
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % calculate the information of the TV term
    z = data.D_TV * x;
    
    t = sign(z);
%     sigma = 1e-5;
    
    % it should be noted that we use 1e-5 to represent 0, that is, when z
    % is very close to 0, we will randomly assign a sub-gradient.
    
%     iz = find(z>0 & z<sigma);
%     t(iz) = rand(length(iz), 1);
    
% %     iz = find(z<0 & z>-sigma);
%     t(iz) = -rand(length(iz), 1);
    
    f2 = sum( abs(z) );
    g2 = data.D_TV' * t;
    
    f = f1 + f2;
    g = g1 + g2;
    
end